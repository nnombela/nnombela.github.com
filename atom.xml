<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[NN.blog.last()]]></title>
  <link href="http://nnombela.github.com/atom.xml" rel="self"/>
  <link href="http://nnombela.github.com/"/>
  <updated>2012-02-15T11:29:10+01:00</updated>
  <id>http://nnombela.github.com/</id>
  <author>
    <name><![CDATA[Nicolas Nombela]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Groovy closures explicados con Java]]></title>
    <link href="http://nnombela.github.com/blog/2012/02/14/groovy-closures-explicados-con-java/"/>
    <updated>2012-02-14T11:26:00+01:00</updated>
    <id>http://nnombela.github.com/blog/2012/02/14/groovy-closures-explicados-con-java</id>
    <content type="html"><![CDATA[<p>Llevando 3 años usando Grails casi de continuo, en mi trabajo es habitual que me pregunten cuánto tiempo le llevaría a un javero de toda la vida
ponerse las pilas y coger ritmo en un proyecto en Grails. Yo siempre respondo lo mismo, Grails es un framework para hacer aplicaciones
web, el javero, a veces muy a su pesar, está muy curtido en esto de probar y utilizar nuevos frameworks, de hecho encontrará Grails
especialmente sencillo y fácil de utilizar, y si es de los que ha bregado a fondo con frameworks del universo (por extenso) Spring incluso
te dirá que de sencillo que es no le parece un framework serio.</p>

<p>Pero el mayor obstáculo y la verdadera dificultad de trabajar con Grails está en el lenguaje que se utiliza: Groovy. Siendo un
lenguaje, Groovy te obliga a cambiar la forma de hacer las cosas y de pensar en ellas.
Afortunadamente la curva de entrada de Groovy para un javero es muy suave, no es una renuncia de Java, es casi una evolución,
al principio es habitual seguir programando igual que en Java y poco a poco ir incorparando la nueva sintáxis y la nueva forma de hacer las cosas.
El tiempo para una adaptación plena varia con la persona, pero típicamente lleva varias semanas o incluso meses, depende de las ganas que le ponga.</p>

<p>Y de todas las dificultades la mayor que se va a encontrar, y probablemente la última en superar, será entender y usar adecuadamente el concepto de
<code>Closure</code> en Groovy. Personalmente (es lo que a mi me ocurrió) creo que la mayor dificultad para entenderlo es que normalmente se explica
en lenguaje convencional o natural, en Inglés o en Castellano, y dicho así no se pilla.</p>

<p>Un ejercicio bastante didáctico, y que espero ayude a captar el concepto <code>Closure</code> más rápidamente a un javero, es intentar explicarlo en Java&#8230;</p>

<p>Vamos a ello, para modelar los closures vamos a utilizar dos aspectos del lenguaje Java poco usados que son: las clases anonimas y las clases internas.</p>

<p>De momento un <code>Closure</code> se puede modelar en Java como una interfaz, con un único método <code>execute()</code> que acepta un mapa de argumentos
y devuelve un resultado.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Closure</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Una implementación del método <code>forEach()</code> utilizando closures sería esta</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="n">Object</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Collection</span> <span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">,</span> <span class="n">Closure</span> <span class="n">closure</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">args</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;index&quot;</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
</span><span class='line'>        <span class="n">args</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;it&quot;</span><span class="o">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">closure</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">collection</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y un ejemplo de uso en Java del anterior código sería el siguiente</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="c1">// First we build the a collection</span>
</span><span class='line'>    <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="n">collection</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Hola&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">collection</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Adios&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Then we traverse the collection</span>
</span><span class='line'>    <span class="n">forEach</span><span class="o">(</span><span class="n">collection</span><span class="o">,</span> <span class="k">new</span> <span class="n">Closure</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;index&quot;</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;it&quot;</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot; Caracola&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>En java usamos clases anónimas para crear el closure, pero la sintaxis como puede observarse no es muy intuitiva.
En groovy el código anterior quedaría reducido a</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">[</span><span class="err">&#39;</span><span class="n">Hola</span><span class="err">&#39;</span><span class="o">,</span> <span class="err">&#39;</span><span class="n">Adios</span><span class="err">&#39;</span><span class="o">].</span><span class="na">eachWithIndex</span> <span class="o">{</span> <span class="n">it</span><span class="o">,</span> <span class="n">index</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">println</span> <span class="s">&quot;$index : $it Caracola&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Nota: El método <code>eachWithIndex()</code> debería de llamarse <code>each()</code> a secas, ver <a href="http://jira.codehaus.org/browse/GROOVY-1182">remove eachWithIndex</a></p></blockquote>

<p>Si esto fuese todo, los closures no serían complicados de entender pero la cosa se complica cuando tenemos en cuenta el
aspecto más interesante de los closures:
<strong>los closures tienen acceso a las variables del contexto donde fueron creados</strong>. Para modelar esto en Java es necesario
introducir una nueva entidad <code>Context</code>.
En java existe algo parecido a los closures en el aspecto de llevar consigo el contexto donde fueron creados, que son las inner clases, y de hecho se metieron en la especificación
final de Java con esta idea y con muchas dudas (que el tiempo a confirmado fundadas) sobre su utilidad.</p>

<p>Vamos a modelar el contexto con un clase <code>Context</code> (qué basicamente es un mapa de variables) y el closure con una clase interna (inner class)
que está vez no será una interfaz si no una clase abstracta. Los argumentos del método <code>execute()</code> serán en vez de un mapa un <code>Context</code>
y podemos crear los argumentos usando el método <code>createArgs()</code> del objeto <code>Closure</code>. El objeto <code>Context</code> puede tener a su vez un
contexto &#8220;padre&#8221;, pudiendo formar una cadena de contextos.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Context</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Context</span> <span class="n">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">variables</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Context</span><span class="o">(</span><span class="n">Context</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Context</span> <span class="nf">add</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">variables</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">object</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Traverse context chain</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">variables</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">name</span><span class="o">)?</span> <span class="n">variables</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">:</span>
</span><span class='line'>            <span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">?</span> <span class="n">parent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Closure</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Context</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="n">Context</span> <span class="nf">createArgs</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nf">Context</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">this</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Como podéis ver evidentemente la cosa se ha complidado&#8230;. veamos el método <code>forEach()</code> y el ejemplo de uso que prácticamente no han cambiado.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="n">Object</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Collection</span> <span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">,</span> <span class="n">Context</span><span class="o">.</span><span class="na">Closure</span> <span class="n">closure</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Context</span> <span class="n">args</span> <span class="o">=</span> <span class="n">closure</span><span class="o">.</span><span class="na">createArgs</span><span class="o">().</span>
</span><span class='line'>            <span class="n">add</span><span class="o">(</span><span class="s">&quot;index&quot;</span><span class="o">,</span> <span class="n">i</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;it&quot;</span><span class="o">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">closure</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">collection</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Y el ejemplo de uso en Java</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'><span class="n">collection</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Hola&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">collection</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Adios&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">Context</span> <span class="n">cxt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// No parent context</span>
</span><span class='line'><span class="n">cxt</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;Caracola&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">forEach</span><span class="o">(</span><span class="n">collection</span><span class="o">,</span> <span class="n">cxt</span><span class="o">.</span><span class="na">new</span> <span class="n">Closure</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Context</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;index&quot;</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span><span class="n">args</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;it&quot;</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>Puede que la sintaxis de creación de las clases anónimas dentro de clases internas <code>cxt.new Closure()</code> no te sea familiar, no te preocupes no estás sólo,
yo tuve que mirarlo de nuevo para escribir el post&#8230;</p>

<p>En groovy el código anterior quedaría reducido a</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">def</span> <span class="n">name</span> <span class="o">=</span> <span class="err">&#39;</span><span class="n">Caracola</span><span class="err">&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span><span class="err">&#39;</span><span class="n">Hola</span><span class="err">&#39;</span><span class="o">,</span> <span class="err">&#39;</span><span class="n">Adios</span><span class="err">&#39;</span><span class="o">].</span><span class="na">eachWithIndex</span> <span class="o">{</span> <span class="n">it</span><span class="o">,</span> <span class="n">index</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">println</span> <span class="s">&quot;$index : $it $name&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Espero que el post te haya servido para entender un poco mejor que son los closures de Groovy, de manera que la próxima
vez que veas un closure (recuerda que en Groovy podemos crear uno con la sintaxis simplificada de llaves cerradas <code>{ }</code>),
te preguntes ¿Cuáles son sus argumentos? y ¿Cuál es su contexto? Y sobre todo aunque se parecen mucho no lo confundas con
un método. El método tiene como contexto el objecto al que pertenece, el <code>Closure</code> tiene como contexto el ámbito donde fue creado.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[¿Cuánto de OOP tiene Javascript?]]></title>
    <link href="http://nnombela.github.com/blog/2012/02/12/cuanto-de-oop-tiene-javascript/"/>
    <updated>2012-02-12T14:44:00+01:00</updated>
    <id>http://nnombela.github.com/blog/2012/02/12/cuanto-de-oop-tiene-javascript</id>
    <content type="html"><![CDATA[<p>JavaScript se define como un lenguaje multi-paradigma, que es otra forma de decir que no es un lenguaje puro en el
sentido de seguir un único paradigma de programación. Ciertamente JS es una mezcla de muchas cosas, aunque la raíz es
para mi es, sin duda, la programación funcional (FP), tomando como base este paradigma su creador tomo prestados
conceptos y estilos de programación de otros lenguajes.</p>

<p>Los lenguajes funcionales tienden a tener un estilo de programación declarativo, pero el creador de JS quiso preferenciar
la sintaxis imperativa C-like común en muchos lenguajes (incluído Java), quizás para hacer más accesible el
lenguaje, en cualquier caso, en JS es habitual ver ambos estilos mezclados. Siguiendo con esta extraña mezcla
decidió, cómo no, añadir características de programación orientada a objectos (OOP en inglés) que tan de moda estaba
en aquellos tiempos y añadió dos conceptos básicos de OOP: La definición de objeto y la herencia, y no mucho
más&#8230; y además JS lo hace de un modo muy particular, veamos cómo:</p>

<!-- more -->


<ol>
<li><p><strong>Definición de objeto.</strong> <em>En JS se define un objeto como una agrupación desestructurada de propiedades/valor, nada más, un
mapa de propiedades para entendernos. Es una definición extremadamente simple y es más una estructura de datos que un
concepto OOP riguroso. No hay encapsulación. Algunos de estas propiedades serán funciones que son asignadas al objeto
dinámicamente y éstas funciones pueden usarse como métodos del objeto, en este caso la función recibe un argumento implícito &#8220;this&#8221;
cuyo valor es el objeto al que pertenece la función. Los objetos son creados utilizando, cómo no, una función constructora (que también es un objeto).</em></p></li>
<li><p><strong>Herencia prototípica.</strong> <em>La herencia se consigue utilizando prototipos, que no son más que objetos (gran acierto)
cuyas propiedades son compartidas por una &#8220;familia&#8221; de objetos creados utilizando la misma función constructora
(otro objeto). El prototipo de un objeto no es más que una de sus propiedades (no enumerable), que además puede ser
modificada posteriormente. A su vez los prototipos, como objetos que son, tienen su propio prototipo dando lugar a lo
que se denomina cadena prototípica.</em></p></li>
</ol>


<p>En JavaScript las funciones son objetos y toda la semántica OOP gira entorno al concepto de objeto y al de función como objeto.
Es en esta mezcla tan acertada y equitativa entre los conceptos función y objeto, donde está la magia de JavaScript, al menos en mi
opinión. Otros lenguajes más OOP puros subordinan el concepto de función al de método del objeto, quedando así su
importancia relegada y mal aprovechada&#8230; pero esto ya va más sobre gustos que otra cosa.</p>

<p>Sin entrar en mucho más detalle, no pretendo que de la explicación anterior quede claro cómo hacer herencia OOP en JS
pero sí la idea de que su implementación en el lenguaje está hecha de una forma muy simple, bastante flexible y en mi
opinión (muy discutible) de una forma elegante y coherente, aunque el creador de JS descuidó, y mucho, los detalles (quizás por
las prisas), y ya se sabe que las prisas son malas y que en los detalles se esconde el diablo&#8230;</p>

<p>Esta simplicidad y flexibilidad de los conceptos OOP es uno de los grandes aciertos de JS pero también una de sus
desventajas, ya que no resulta nada obvio cómo programar siguiendo un estilo OOP en JavaScript&#8230; pero en parte también
esto puede ser una ventaja ya que OOP puede no ser la forma más adecuada para resolver un problema de programación. OOP no es un
estilo imperativo en JS, es una opción, casi un patrón de diseño más&#8230; y la dificultad de uso es una forma del
lenguaje, un tanto sutil, de decirle al programador que si no tiene claro como hacerlo es por que, probablemente ¡No
lo necesita! Y en muchas ocasiones esto es cierto.</p>

<p>Y bueno hecha la introducción veamos un par de formas para hacer OOP en Javascript.</p>

<h3>A) Al modo funcional:   <em>Un par de funciones extend() y inherits().</em></h3>

<div><script src='https://gist.github.com/1768497.js?file='></script>
<noscript><pre><code>function extend(dest, source) {
    for (var prop in source) {   // enumerable properties
        dest[prop] = source[prop];
    }
    return dest;
}

function inherits(Parent, props) {
    var Child = props.constructor || function() {};
    delete props.constructor;  // Avoid copying constructor property later

    Child.parent = Parent;
    Child.prototype = Object.create(Parent.prototype, {
        constructor: { value: Child, enumerable: false }
    });

    extend(Child.prototype, props);

    return Child;
}</code></pre></noscript></div>


<p><strong>Para el 80% de los casos</strong>, extender (extend) un objeto utilizando otro objeto, es probablemente la forma más fácil y en
muchas ocasiones la más acertada de tener “herencia” sin hacer herencia, también se denomina “mezclar con” (mixin) o
aumentar (augment) un objeto con otro objeto, está será nuestra primera opción a considerar, su uso es trivial.</p>

<p><strong>Para el 20% de los restantes casos</strong>, si pensándolo bien finalmente decidimos que lo que queremos es herencia pura y dura,
utilizando la función anterior lo haríamos así:</p>

<div><script src='https://gist.github.com/1789034.js?file='></script>
<noscript><pre><code>var Point = inherits(Object, {
    constructor: function(x, y) {
        this.x = x;
        this.y = y;
    },
    // shared properties
    desc : 'A single point',
    // methods
    toString: function () {
        return '(' + this.x + &quot;, &quot; + this.y + ')';
    }
});

var ColorPoint = inherits(Point, {
    constructor: function(x, y , color) {
        ColorPoint.parent.prototype.constructor.call(this, x, y);
        this.color = color;
    },
    // shared properties
    desc: 'A single point plus color',
    // methods
    toString: function() {
        return this.color + &quot; &quot; + ColorPoint.parent.prototype.toString.call(this);
    }
});


var p = new Point(3, 2);
var cp = new ColorPoint(1, 2, &quot;yellow&quot;);

console.log(p.desc + &quot;: &quot; + p.toString());
console.log(cp.desc + &quot;: &quot; + cp.toString());</code></pre></noscript></div>


<p>Lo que me gusta de esta sintaxis es que es muy limpia e intuitiva, se ve claramente lo que estás haciendo y ves al
mismo tiempo y de forma agrupada la función constructora, las propiedades compartidas y los métodos.</p>

<p>Especial atención a cómo se accede a los métodos y propiedades de la “clase padre” desde la “clase hija” .</p>

<pre><code>    Child.parent.prototype.property;
    Child.parent.prototype.functionName.call(this, args..);
</code></pre>

<p>Podríamos haber utilizado perfectamente (y quizás más correctamente) una versión más corta</p>

<pre><code>    Parent.prototype.property;
    Parent.prototype.functionName.call(this, args..);
</code></pre>

<p>Pero he preferido utilizar la propiedad añadida (no enumerable) <code>parent</code> de la función constructora por que es habitual
añadir los métodos posteriormente, una vez hecha la definición, y en estos casos es conveniente no tener que recordar y hacer mención
explicita a la función padre,  de cualquier forma la sintaxis es (discutiblemente) engorrosa, en la siguiente sección veremos una posible alternativa
más sencilla y un poco más OOP (pero con inconvenientes que explicaré).</p>

<hr />

<br/>


<h3>B) A un modo más OOP:  <em>Utilizando modularización y encapsulación.</em></h3>

<p>Esta opción es una evolución de la anterior pero con un enfoque más orientado a objectos, en vez de utilizar funciones
haremos que las las funciones constructoras extiendan de un objeto padre (OOP) que tiene como métodos
el método <code>extend()</code> para herencia y el método <code>augment()</code> para extender (ya se que el cruce de nombres es un poco confuso
pero las terminologías FP y la OOP se solapan y tienen estas cosas, lo siento). El código además se presenta como una
librería modularizada (con soporte CommonJS)</p>

<div><script src='https://gist.github.com/1768435.js?file='></script>
<noscript><pre><code>var OOP = (function() {

    var SLICE = Array.prototype.slice;

    function extend(source) {
        for (var prop in source) {   // enumerable properties
            var value = source[prop];

            if (value.type === 'descriptor') { // mark descriptor object with type = 'descriptor'
                Object.defineProperty(this, prop, value);
            } else {
                this[prop] = value;
            }
        }
        return this;
    }

    function bind(func) {
        var obj = this;
        return function() {
            return obj[func].apply(obj, SLICE.call(arguments));
        };
    }

    function inherits(props) {
        var Parent = this;
        var Child = props.constructor || function() {};

        Child.parent = Parent;
        Child.prototype = Object.create(Parent.prototype, {
            constructor: { value: Child, enumerable: false },
            parent: { value: function(name) {
                var obj = Parent.prototype[name];
                return obj &amp;&amp; obj.apply? obj.apply(this, SLICE.call(arguments, 1)) : obj;
            }, enumerable: false}
        });

        delete props.constructor;  // Avoid copying constructor property
        extend.call(Child.prototype, props);

        return Child;
    }

    // Create OOP object by extending Object
    return inherits.call(Object, {
        augment: { type: 'descriptor', value: extend, enumerable: false },
        extend: { type: 'descriptor', value: inherits, enumerable: false },
        method: { type: 'descriptor', value: bind, enumerable: false }
    });
}());

if (typeof exports !== 'undefined') { // CommonJS module support
    exports = OOP;
}</code></pre></noscript></div>


<p>Como ejemplo de uso de la librería anterior tenemos.</p>

<div><script src='https://gist.github.com/1792721.js?file='></script>
<noscript><pre><code>var OOP = require('./OOP.js');

var Point = OOP.extend({
    constructor: function(x, y) {
        this.x = x;
        this.y = y;
    },
    desc : 'A single point',
    toString: function () {
        return '(' + this.x + &quot;, &quot; + this.y + ')';
    }
});

// Now you can easily extend Point

var ColorPoint = Point.extend({
    constructor: function(x, y , color) {
        //ColorPoint.parent.prototype.constructor.call(this, x, y);
        this.parent('constructor', x, y);   // calling parent constructor
        this.color = color;
    },
    desc: 'A single point plus color',
    toString: function() {
        // return this.color + &quot; &quot; + ColorPoint.parent.prototype.toString.call(this)
        return this.color + &quot; &quot; + this.parent('toString');   // calling parent method
    },
    printLog: function() {
        console.log('LOG: ' + this.toString());
    }
});

var p = new Point(3, 2);
var cp = new ColorPoint(1, 2, &quot;yellow&quot;);

console.log(p.desc + &quot;: &quot; + p.toString());
console.log(cp.desc + &quot;: &quot; + cp.toString());

setTimeout(cp.method('printLog'), 1000);</code></pre></noscript></div>


<p>El ejemplo es parecido al anterior en A) pero en vez de funciones utilizamos métodos (funciones de un objeto) y además he añadido una forma un
poco más amigable de poder llamar a los metodos de la “clase padre” (prototipo de la función constructora), de manera
que en vez de</p>

<pre><code>    ColorPoint.parent.prototype.constructor.call(this, x, y);
    ColorPoint.parent.prototype.toString.call(this);
</code></pre>

<p>Podemos, si queremos, usar de manera equivalente:</p>

<pre><code>    this.parent('constructor', x, y);
    this.parent('toString');
</code></pre>

<p>Esta segunda posibilidad aunque más intuitiva y sencilla tiene un inconveniente importante, las funciones método sólo
podrán ser utilizadas ligándolas a objetos del
&#8220;mismo tipo&#8221; (misma función constructora) al objeto al que pertenecen, es decir no podrán utilizarse como funciones desligadas
con objetos que en su cadena prototípica no tengan la función <code>parent()</code> con la misma semántica, esto nos aleja de una programación funcional
y nos acerca más a la programación OOP, pero bueno es opcional y dependiendo de nuestro diseño no tiene por qué ser negativo.</p>

<p>Para facilitar la operación de ligar una funcion con el objeto al que pertenece he includo un método no enumerado
dentro de la cadena prototípica que se llama <code>method()</code>, podéis ver su uso en el ejemplo para generar una función
callback como argumento de un <code>setTimeout()</code>. Todo el tema de funciones, métodos y funciones ligadas es muy importante
en JS y uno de los que más confusión genera especialmente al principio si se viene de programar en Java donde esta
problemática no existe, como este post ya es bastante largo lo dejo para uno futuro.</p>

<blockquote><p><strong>Un aviso,</strong> la herencia es probablemente el recurso más incorrectamente utilizado en programación OOP, especialmente
en aquellos lenguajes más OOP puros que incitan a utilizarlo. Los diseños evolutivos son los que más padecen el uso
o abuso de este recurso ya que la herencia es la decisión que más rigidez y difulcultad de cambio aportan a un diseño
(si eres de los que ha utilizado herencia con profusión en un modelo de datos sabrás de lo que estoy
hablando). Java se intentó proteger de este abuso no permitiendo la herencia múltiple y favoreciendo más el uso de
interfaces, aún con todo incluso en las librerías estándar, especialmente en las más antiguas, es fácil ver este
problema. Ver <a href="http://asserttrue.blogspot.com/2009/02/inheritance-as-antipattern.html">Inheritance as antipattern</a>, asi que&#8230; <br/>
<strong>Use it at your own risk!</strong></p></blockquote>

<p>JavaScript es un lenguaje muy incomprendido&#8230; espero que este post os haya servido para entenderlo un poco mejor o
al menos haber despertado vuestro interés. Intentaré seguir en ello.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sobre este blog]]></title>
    <link href="http://nnombela.github.com/blog/2012/02/11/sobre-este-blog/"/>
    <updated>2012-02-11T19:10:00+01:00</updated>
    <id>http://nnombela.github.com/blog/2012/02/11/sobre-este-blog</id>
    <content type="html"><![CDATA[<h2>¿Por qué <a href="http://octopress.org/">Octopress</a> ?</h2>

<p>Después de probar varias opciones online, finalmente me he decidido a utilizar Octopress, por varias razones</p>

<ul>
<li>Es un blog de publicación estática con total control sobre lo que aparece, como tiene que ser&#8230;</li>
<li>Puede alojarse en <a href="http://github.com">github</a> gratuítamente y la carga de páginas es muy rápida, como ventaja añadida todo el blog está versionado.</li>
<li>El diseño por defecto es muy simple, limpio y fácilmente modificable.</li>
<li>Es un blog de programadores para programadores y se nota. Está hecho en Ruby, qeu no conozco bien pero es fácil de utilizar.</li>
<li>Es muy fácil incluir código en las entradas y se integra con <code>github gist</code> (trozos de código) estupendamente.</li>
<li>Es posible trabajar offline, viendo rápidamente los cambios y utilizando mi IDE favorito, cuando estás conforme haces un <code>push</code> a github</li>
<li>Utiliza un lenguaje de marcado <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a> (configurable) en vez de uno
de estos asistentes de edición que siempre me funcionan mal, para mi es más cómodo.</li>
<li>Tiene un montón de plugins en código abierto y si no te sirven los modificas o te haces uno.</li>
</ul>

]]></content>
  </entry>
  
</feed>
